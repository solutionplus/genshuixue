mysql存储引擎：
myisam：读的效果好（因为MyISAM是表锁，所以查询快），写的效率差，myisam锁是表锁，只有读读之间是并发的，

innodb：一般都是行锁（语言里都有加锁的语句），读写之间是可以并发的，支持事务，外键，行级锁
InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与ORACLE不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。


为什么innodb要使用聚集索引？
1、为了得到更高效的查询，插入，或者其他的数据库操作，innodb引擎使用聚簇索引可以优化大多数查询和dml操作
2、如果表特别大，聚簇索引的这种构造就能节省磁盘I/O资源（比如myiasm的索引和数据在不同页上时，根据索引来寻找数据存储页消耗的IO）
3、聚集索引的好处：聚集索引并不是按照物理顺序存储的，虽然只是逻辑上的连续， 对于主键的排序查找和范围查找速度非常的快  例如：要查找一个注册用户表中最近注册的10个用户，可以通过查找最后一个数据页，并取出10条记录，范围查找：如果要查找某一个范围的数据，通过页节点上层的中间节点就可以得到页的范围，之后读取数据页。

既然innodb使用聚集索引，那为什么使用聚集索引的innodb比myisam的读的速度慢？
因为MyISAM是表锁，所以查询快，而innodb是行锁，所以慢

读：MyISAM 默认会把索引读入内存，直接在内存中操作；InnoDB 则是 I/O 操作。（参考stackoverflow，具体url忘记了）
写：MyISAM 是表锁；InnoDB 是行锁。在执行数据库写入的操作（insert,update,delete）的时候，mysiam表会锁表，而innodb表会锁行。通俗点说，就是你执行了一个update语句，那么mysiam表会将整个表都锁住，其他的insert和delete、update都会被拒之门外，等到这个update语句执行完成后才会被依次执行。