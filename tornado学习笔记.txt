
一、安装 Tornado
    目前最新版本的下载:  http://github.com/downloads/facebook/tornado/tornado-1.2.1.tar.gz
    参考: http://www.tornadoweb.org/

    解压之后, 进入解压的目录, 执行:
        python setup.py build
        python setup.py install

    如果开发环境是py2.6+, 也可以简单的把tornado目录添加到py的环境变量 PYTHONPATH 中, 这样就不需要编译setup.py(也就是不用安装的意思)


    安装条件:
    在py2.5, 2.6, 2.7上进行过测试, 如果要使用 tornado 的全部功能, 必须安装 PycURL (版本7.18.2 或者以上, http://pycurl.sourceforge.net/ ), 对py2.5必须安装JSON支持组件simplejson(http://pypi.python.org/pypi/simplejson/), py2.6+以上的JSON支持已经在标准库内实现。

    安装方式:
    #Mac OS X 10.6 (Python 2.6+)
    sudo easy_install setuptools pycurl

    #Ubuntu Linux (Python 2.6+)
    sudo apt-get install python-pycurl

    #Ubuntu Linux (Python 2.5)
    sudo apt-get install python-dev python-pycurl python-simplejson


二、模块列表和简介:
    最重要的模块是web模块, 他作为web框架包含了 Tornado 包内大部分的有用的东西, 其他的工具和模块让web变的更有用

    主模块
        web – 用来创建FriendFeed的web框架, 他集成(混合)了大部分 Tornado 的重要功能特征
        escape – XHTML, JSON, and URL 编解码方法
        database -对MySQLdb的简单封装, 让mysql的使用更方便
        template – 基于python的模板渲染语言
        httpclient – 一个非阻塞http客户端, 设计它用来和web和httpserver协同工作
        auth – 第三方认证和认证方案的实现 (Google OpenID/OAuth, Facebook Platform, Yahoo BBAuth, FriendFeed OpenID/OAuth, Twitter OAuth)
        locale – 本地化和翻译支持
        options – 命令行和配置文件解析工具, 为了webserver环境做了优化

    底层模块
        httpserver – A very simple HTTP server built on which web is built
        iostream – A simple wrapper around non-blocking sockets to aide common reading and writing patterns
        ioloop – Core I/O loop

    随机模块:
        s3server – 一个实现了Amazon S3接口的web服务器, 基于本地文件存储


三、Tornado使用概览
  1.请求处理程序和请求参数
    Tornado 的 Web 程序会将 URL 或者 URL 范式映射到 tornado.web.RequestHandler 的子类上去。在其子类中定义了 get() 或 post() 方法, 用以处理不同的 HTTP 请求。

    下面的代码将 URL 根目录 “/” 映射到 “MainHandler”, 还将一个 URL 范式 “/story/([0-9]+)” 映射到 “StoryHandler”。
    正则表达式匹配的分组会作为参数引入 的相应方法中:
     class MainHandler(tornado.web.RequestHandler):
        def get(self):
            self.write("You requested the main page")

    class StoryHandler(tornado.web.RequestHandler):
        def get(self, story_id):
            self.write("You requested the story " + story_id)

    application = tornado.web.Application([
        (r"/", MainHandler),
        (r"/story/([0-9]+)", StoryHandler),
    ])


    你可以使用 get_argument() 方法来获取查询字符串参数(如果没有传递此参数过来则会出错), 以及解析 POST 的内容:
     class MainHandler(tornado.web.RequestHandler):
        def get(self):
            self.write('<html><body><form action="/" method="post">'
                       '<input type="text" name="message"/>'
                       '<input type="submit" value="Submit"/>'
                       '</form></body></html>')

        def post(self):
            self.set_header("Content-Type", "text/plain")
            self.write("You wrote " + self.get_argument("message"))

    上传的文件可以通过 self.request.files 访问到, 该对象将名称(HTML元素 <input type="file">的 name 属性)对应到一个文件列表。
    每一个文件都以字典的形式 存在, 其格式为: {"filename":..., "content_type":..., "body":...}。

    如果你想要返回一个错误信息给客户端, 例如“403 unauthorized”, 只需要抛出一个 tornado.web.HTTPError 异常:
     if not self.user_is_logged_in():
        raise tornado.web.HTTPError(403)

    请求处理程序可以通过 self.request 访问到代表当前请求的对象。该 HTTPRequest 对象包含了一些有用的属性, 包括:
     arguments - 所有的 GET 或 POST 的参数
     files - 所有通过 multipart/form-data POST 请求上传的文件
     path - 请求的路径 ( ? 之前的所有内容)
     headers - 请求的头信息

    可以通过查看源代码 httpserver 模组中 HTTPRequest 的定义, 从而了解到它的 所有属性。


  2.重写 RequestHandler 的方法函数
    除了 get()/post() 等以外, RequestHandler 中的一些别的方法函数, 这都是 一些空函数, 它们存在的目的是在必要时在子类中重新定义其内容。
    对于一个请求的处理 的代码调用次序如下:
     1.程序为每一个请求创建一个 RequestHandler 对象
     2.程序调用 initialize() 函数, 这个函数的参数是 Application 配置中的关键字 参数定义。(initialize 方法是 Tornado 1.1 中新添加的, 旧版本中你需要 重写 __init__ 以达到同样的目的) initialize 方法一般只是把传入的参数存 到成员变量中, 而不会产生一些输出或者调用像 send_error 之类的方法。
     3.程序调用 prepare()。无论使用了哪种 HTTP 方法, prepare 都会被调用到, 因此 这个方法通常会被定义在一个基类中, 然后在子类中重用。prepare可以产生输出 信息。如果它调用了finish(或send_error` 等函数), 那么整个处理流程 就此结束。
     4.程序调用某个 HTTP 方法: 例如 get()、 post()、 put() 等。如果 URL 的正则表达式模式中有分组匹配, 那么相关匹配会作为参数传入方法。

    其它设计用来被复写的方法有:
     get_error_html(self, status_code, exception=None, **kwargs) # 以字符串的形式 返回 HTML, 以供错误页面使用。
     get_current_user(self) # 查看下面的用户认证一节
     get_user_locale(self) # 返回 locale 对象, 以供当前用户使用。
     get_login_url(self) # 返回登录网址, 以供 @authenticated 装饰器使用(默认位置 在 Application 设置中)
     get_template_path(self) # 返回模板文件的路径(默认是 Application 中的设置)

  3.重定向(redirect)
    Tornado 中的重定向有两种主要方法: self.redirect, 或者使用 RedirectHandler。
    可以在使用 RequestHandler (例如 get)的方法中使用 self.redirect, 将用户 重定向到别的地方。另外还有一个可选参数 permanent, 你可以用它指定这次操作为永久性重定向。
    该参数会激发一个 301 Moved Permanently HTTP 状态, 这在某些情况下是有用的,  例如, 你要将页面的原始链接重定向时, 这种方式会更有利于搜索引擎优化(SEO)。

    permanent 的默认值是 False, 这是为了适用于常见的操作, 例如用户端在成功发送 POST 请求 以后的重定向。
     self.redirect('/page.html', permanent=True)

    RedirectHandler 会在初始化 Application 时自动生成。
    例如本站的下载 URL, 由较短的 URL 重定向到较长的 URL 的方式是这样的:
     application = tornado.wsgi.WSGIApplication([
        (r"/([a-z]*)", ContentHandler),
        (r"/static/tornado-0.2.tar.gz", tornado.web.RedirectHandler,
         dict(url="http://github.com/downloads/facebook/tornado/tornado-0.2.tar.gz")),
    ], **settings)

    RedirectHandler 的默认状态码是 301 Moved Permanently, 不过如果你想使用 302 Found 状态码, 你需要将 permanent 设置为 False。
     application = tornado.wsgi.WSGIApplication([
        (r"/foo", tornado.web.RedirectHandler, {"url":"/bar", "permanent":False}),
    ], **settings)

    注意, 在 self.redirect 和 RedirectHandler 中, permanent 的默认值是不同的。 这样做是有一定道理的, self.redirect 通常会被用在自定义方法中, 是由逻辑事件触发 的(例如环境变更、用户认证、以及表单提交)。而 RedirectHandler 是在每次匹配到请求 URL 时被触发。


四、模板
    Tornado 模板其实就是 HTML 文件(也可以是任何文本格式的文件), 其中包含了 Python 控制结构和表达式, 这些控制结构和表达式需要放在规定的格式标记符(markup)中。
    Tornado 的模板支持“控制语句”和“表达语句”, 控制语句是使用 {% 和 %} 包起来的 例如 {% if len(items) > 2 %}。表达语句是使用 {{ 和 }} 包起来的, 例如 {{ items[0] }}。
    控制语句和对应的 Python 语句的格式基本完全相同。支持 if 、 for 、 while 和 try, 这些语句逻辑结束的位置需要用 {% end %} 做标记。我们还通过 extends 和 block 语句实现了模板继承。这些在 template 模块(http://github.com/facebook/tornado/blob/master/tornado/template.py) 的代码文档中有着详细的描述。


    tornado的文档非常的匮乏, 不过这是表面现象, 其实个中乾坤都在源文件里, 源文件的注释里有非常的文档资料, 值得仔细研究。
    A simple template system that compiles templates to Python code.
    一个简单的模板系统, 将模板编译成python代码

    Basic usage looks like:
    基本的用法如下:

        t = template.Template("<html>{{ myvalue }}</html>")
        print t.generate(myvalue="XXX")

    Loader is a class that loads templates from a root directory and caches the compiled templates:
    加载器是一个从根目录加载模板文件并编译缓存模板的类

        loader = template.Loader("/home/btaylor")
        print loader.load("test.html").generate(myvalue="XXX")

    We compile all templates to raw Python. Error-reporting is currently... uh, interesting. Syntax for the templates:
    我们编译所有模板为python代码, (目前会报错。。。。注: 可能是开发时候写下来的)

        ### base.html
        <html>
          <head>
            <title>{% block title %}Default title{% end %}</title>
          </head>
          <body>
            <ul>
              {% for student in students %}
                {% block student %}
                  <li>{{ escape(student.name) }}</li>
                {% end %}
              {% end %}
            </ul>
          </body>
        </html>

        ### bold.html
        {% extends "base.html" %}
        {% block title %}A bolder title{% end %}
        {% block student %}
          <li><span style="bold">{{ escape(student.name) }}</span></li>
        {% end %}

    Unlike most other template systems, we do not put any restrictions on the expressions you can include in your statements.
    if and for blocks get translated exactly into Python, you can do complex expressions like:
    与其他模板系统不同的是, 我们没有对你在模板声名中植入的表达式做任何限制。
    if 和 for 块完全支持Python的语法, 你可以使用完整的写法, 如下:

       {% for student in [p for p in people if p.student and p.age > 23] %}
         <li>{{ escape(student.name) }}</li>
       {% end %}

    Translating directly to Python means you can apply functions to expressions easily, like the escape() function in the examples above. You can pass
    functions in to your template just like any other variable:
    直接转义成python代码意味着你可以轻松的在表达式里调用方法, 譬如上面调用escape函数的例子, 你也可以将函数当成任何其他变量一样的传递到模板中

       ### Python code
       def add(x, y):
          return x + y
       template.execute(add=add)

       ### The template
       {{ add(1, 2) }}

    We provide the functions escape(), url_escape(), json_encode(), and squeeze() to all templates by default.
    每个模板默认提供了 escape(), url_escape(), json_encode(), and squeeze() 这几个函数


    Typical applications do not create `Template` or `Loader` instances by hand, but instead use the `render` and `render_string` methods of `tornado.web.RequestHandler`, which load templates automatically based on the ``template_path`` `Application` setting.
    默认的application不会手动创建Template和Loader的实例, 而是通过调用`tornado.web.RequestHandler`实例中的 render, render_string 方法。
    这些方法通过Application的setting里面的`template_path`这一项的设置自动加载目录里的模板

    Syntax Reference
    Template expressions are surrounded by double curly braces: ``{{ ... }}``.
    The contents may be any python expression, which will be escaped according to the current autoescape setting and inserted into the output.
    Other template directives use ``{% %}``.
    These tags may be escaped as ``{{!`` and ``{%!`` if you need to include a literal ``{{`` or ``{%`` in the output.

    模板表达式用两个大括号包裹起来: ``{{ ... }}``.
    内容可以是任何Python表达式, 表达式会使用当前的 autoescape 设置转义并插入到输出中。
    其他模板指令使用 `{%    %}`。这些标签会被转义成 ``{{!``和 ``{%!`` , 如果你需要插入 ``{{``或者 ``{%``到输出中。

    ``{% apply *function* %}...{% end %}``
        Applies a function to the output of all template code between ``apply`` and ``end``:
        将这个标签之间的模板输出作为一个参数应用到一个方法, 如下:
        {% apply linkify %}{{name}} said: {{message}}{% end %}

    ``{% autoescape *function* %}``
        Sets the autoescape mode for the current file.
        This does not affect other files, even those referenced by ``{% include %}``.
        Note that autoescaping can also be configured globally, at the `Application` or `Loader`.:
        这个标签用来设置当前文件的自动转义模式。这项设置对其他文件无效, 即时是哪些插入了当前文件的模板。
        自动转义也能够在Application和Loader中全局设置。

            {% autoescape xhtml_escape %}
            {% autoescape None %}

    ``{% block *name* %}...{% end %}``
        Indicates a named, replaceable block for use with ``{% extends %}``.
        Blocks in the parent template will be replaced with the contents of the same-named block in a child template.:
        表示一个命名的可以被替换的块,  和``{% extends %}``一起使用。在父模板中的这些块将被自模板中同名的块替代

            <!-- base.html -->
            <title>{% block title %}Default title{% end %}</title>
            <!-- mypage.html -->
            {% extends "base.html" %}
            {% block title %}My page title{% end %}

    ``{% comment ... %}``
        A comment which will be removed from the template output.
        Note that there is no ``{% end %}`` tag; the comment goes from the word ``comment`` to the closing ``%}`` tag.
        注释块, 不会输出。主意不需要 `{% end %}` 标签；

    ``{% extends *filename* %}``
        Inherit from another template.
        Templates that use ``extends`` should contain one or more ``block`` tags to replace content from the parent template.
        Anything in the child template not contained in a ``block`` tag will be ignored.  For an example, see the ``{% block %}`` tag.
        继承其他的模板。
        使用extends标签的模板需要包含一个到多个block标签用来替换父模板中的同名的块。
        子模板中任何不在块中的内容将被忽略掉。例子可参见 ``{% block %}``标签那一节

    ``{% for *var* in *expr* %}...{% end %}``
        Same as the python ``for`` statement.
        for 循环标签, 等同于Python中的for表达式

    ``{% from *x* import *y* %}``
        Same as the python ``import`` statement.
        import 标签, 等同于 import 表达式

    ``{% import *module* %}``
        Same as the python ``import`` statement.
        import 标签的另一种写法

    ``{% if *condition* %}...{% elif *condition* %}...{% else %}...{% end %}``
        Conditional statement - outputs the first section whose condition is true.  (The ``elif`` and ``else`` sections are optional)
        if 条件表达式标签, 等同于python的 if ... elif ... else ... 表达式


    ``{% include *filename* %}``
        Includes another template file.
        The included file can see all the local variables as if it were copied directly to the point of the ``include`` directive (the ``{% autoescape %}`` directive is an exception).
        Alternately, ``{% module Template(filename, **kwargs) %}`` may be used to include another template with an isolated namespace.
        引用另外的模板文件。
        被引入的文件可以访问引入它的模板的所有locals变量, 相当于是直接copy了被引入模板文件的内容。
        autoescape节有例子。
        另外``{% module Template(filename,**kwargs) %}``可以用来引入一个模板文件在一个独立的namespace中

    ``{% module *expr* %}``
        Renders a `~tornado.web.UIModule`.  The output of the ``UIModule`` is not escaped:
        插入一个UI模块的标签, UI模块的输出没有经过转义的
            {% module Template("foo.html", arg=42) %}

    ``{% raw *expr* %}``
        Outputs the result of the given expression without autoescaping.
        不经过转义输出一个表达式的值, 默认情况下会把内容转码成 html 的显示格式

    ``{% set *x* = *y* %}``
        Sets a local variable.
        创建一个本地变量, 如:
        {% set index = 0 %}
        {% for ar in Result.archives %}
            {% set index += 1 %}
        {% end %}

    ``{% try %}...{% except %}...{% finally %}...{% end %}``
        Same as the python ``try`` statement.
        和Python 的 try ... except ...  块特性一致

    ``{% while *condition* %}... {% end %}``
        Same as the python ``while`` statement.
        和Python里 while 语句一致


五、函数
    Tornado 模板的 表达语句可以是包括函数调用在内的任何 Python 表述。模板中的相关代码, 会在一个单独 的名字空间中被执行, 这个名字空间包括了以下的一些对象和方法。(注意, 下面列表中 的对象或方法在使用 RequestHandler.render 或者 render_string 时才存在的 , 如果你在 RequestHandler 外面直接使用 template 模块, 则它们中的大部分是不存在的)。

    escape: tornado.escape.xhtml_escape 的別名
        转成html编码,如: escape(" ") 显示成 "&nbsp;"
    xhtml_escape: tornado.escape.xhtml_escape 的別名
    url_escape: tornado.escape.url_escape 的別名
    json_encode: tornado.escape.json_encode 的別名
    squeeze: tornado.escape.squeeze 的別名
    linkify: tornado.escape.linkify 的別名
    datetime: Python 的 datetime 模组
    handler: 当前的 RequestHandler 对象
    request: handler.request 的別名
    current_user: handler.current_user 的別名
    locale: handler.locale 的別名
    _: handler.locale.translate 的別名
    static_url: for handler.static_url 的別名
    xsrf_form_html: handler.xsrf_form_html 的別名
    reverse_url: Application.reverse_url 的別名
    Application 设置中 ui_methods 和 ui_modules 下面的所有项目
    任何传递给 render 或者 render_string 的关键字参数


  1.转码
    所有的模板输出都已经通过 tornado.escape.xhtml_escape 自动转义(escape)
    这种默认行为, 可以通过以下几种方式修改:
        1.将 autoescape=None 传递给 Application 或者 TemplateLoader
        2.在模板文件中加入 {% autoescape None %}
        3.简单表达语句 {{ ... }} 写成 {% raw ...%}。
    另外你可以在上述位置将 autoescape 设为一个自定义函数, 而不仅仅是 None 。

  2.Cookie 和安全 Cookie
    可以使用 set_cookie, get_cookie 方法在用户的浏览中设置及获取 cookie:
     class MainHandler(tornado.web.RequestHandler):
        def get(self):
            if not self.get_cookie("mycookie"):
                self.set_cookie("mycookie", "myvalue")
                self.write("Your cookie was not set yet!")
            else:
                self.write("Your cookie was set!")

    Cookie 很容易被恶意的客户端伪造。假如想在 cookie 中保存当前登陆用户的 id 之类的信息, 则需要对 cookie 作签名以防止伪造。
    Tornado 通过 set_secure_cookie 和 get_secure_cookie 方法直接支持了这种功能。 要使用这些方法, 需要在创建应用时提供一个密钥, 名字为 cookie_secret。
    可以把它作为一个关键词参数传入应用的设置中:
     application = tornado.web.Application([
        (r"/", MainHandler),
    ], cookie_secret="61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=")

    签名过的 cookie 中包含了编码过的 cookie 值, 另外还有一个时间戳和一个 HMAC 签名。
    如果 cookie 已经过期或者 签名不匹配, get_secure_cookie 将返回 None, 这和没有设置 cookie 时的 返回值是一样的。
    上面例子的安全 cookie 版本如下:
     class MainHandler(tornado.web.RequestHandler):
        def get(self):
            if not self.get_secure_cookie("mycookie"):
                self.set_secure_cookie("mycookie", "myvalue")
                self.write("Your cookie was not set yet!")
            else:
                self.write("Your cookie was set!")

  3.用户认证
    当前已经认证的用户信息被保存在每一个请求处理器的 self.current_user 当中,  同时在模板的 current_user 中也是。默认情况下, current_user 为 None 。
    要在应用程序实现用户认证的功能, 需要复写请求处理中 get_current_user() 这个方法, 在其中判定当前用户的状态, 比如通过 cookie。
    下面的例子让用户简单地使用一个 nickname 登陆应用, 该登陆信息将被保存到 cookie 中:
     class BaseHandler(tornado.web.RequestHandler):
        def get_current_user(self):
            return self.get_secure_cookie("user")

    class MainHandler(BaseHandler):
        def get(self):
            if not self.current_user:
                self.redirect("/login")
                return
            name = tornado.escape.xhtml_escape(self.current_user)
            self.write("Hello, " + name)

    class LoginHandler(BaseHandler):
        def get(self):
            self.write('<html><body><form action="/login" method="post">'
                       'Name: <input type="text" name="name"/>'
                       '<input type="submit" value="Sign in"/>'
                       '</form></body></html>')

        def post(self):
            self.set_secure_cookie("user", self.get_argument("name"))
            self.redirect("/")

    application = tornado.web.Application([
        (r"/", MainHandler),
        (r"/login", LoginHandler),
    ], cookie_secret="61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=")


    对于那些必须要求用户登陆的操作, 可以使用装饰器 tornado.web.authenticated。
    如果一个方法套上了这个装饰器, 但是当前用户并没有登陆的话, 页面会被重定向到 login_url(应用配置中的一个选项)
    上面的例子可以被改写成:
     class MainHandler(BaseHandler):
        @tornado.web.authenticated
        def get(self):
            name = tornado.escape.xhtml_escape(self.current_user)
            self.write("Hello, " + name)

    settings = {
        "cookie_secret": "61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=",
        "login_url": "/login",
    }
    application = tornado.web.Application([
        (r"/", MainHandler),
        (r"/login", LoginHandler),
    ], **settings)

    如果你使用 authenticated 装饰器来装饰 post() 方法, 那么在用户没有登陆的状态下,  服务器会返回 403 错误。
    Tornado 内部集成了对第三方认证形式的支持, 比如 Google 的 OAuth 。参阅 auth 模块(https://github.com/facebook/tornado/blob/master/tornado/auth.py) 的代码文档以了解更多信息。 Checkauth 模块以了解更多的细节。
    在 Tornado 的源码中有一个 Blog 的例子, 你也可以从那里看到 用户认证的方法(以及如何在 MySQL 数据库中保存用户数据)。


  4.跨站伪造请求的防范
    跨站伪造请求(Cross-site request forgery), 简称为 XSRF, 是个性化 Web 应用中常见的一个安全问题。
    当前防范 XSRF 的一种通用的方法, 是对每一个用户都记录一个无法预知的 cookie 数据, 然后要求所有提交的请求中都必须带有这个 cookie 数据。如果此数据不匹配 , 那么这个请求就可能是被伪造的。
    Tornado 有内建的 XSRF 的防范机制, 要使用此机制, 你需要在应用配置中加上 xsrf_cookies 设定:
     settings = {
        "cookie_secret": "61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=",
        "login_url": "/login",
        "xsrf_cookies": True,
    }
    application = tornado.web.Application([
        (r"/", MainHandler),
        (r"/login", LoginHandler),
    ], **settings)


    如果设置了 xsrf_cookies, 那么 Tornado 的 Web 应用将对所有用户设置一个 _xsrf 的 cookie 值, 如果 POST PUT DELET 请求中没有这个 cookie 值, 那么这个请求会被直接拒绝。
    如果开启了这个机制, 那么在所有被提交的表单中, 都需要加上一个域来提供这个值。可以通过在模板中使用专门的函数 xsrf_form_html() 来做到这一点:
     <form action="/new_message" method="post">
      {{ xsrf_form_html() }}
      <input type="text" name="message"/>
      <input type="submit" value="Post"/>
    </form>


    如果提交的是 AJAX 的 POST 请求, 还需要在每一个请求中通过脚本添加上 _xsrf 这个值, 下面是 使用了 jQuery 的 js 代码:
     function getCookie(name) {
        var r = document.cookie.match("\\b" + name + "=([^;]*)\\b");
        return r ? r[1] : undefined;
    }

    jQuery.postJSON = function(url, args, callback) {
        args._xsrf = getCookie("_xsrf");
        $.ajax({url: url, data: $.param(args), dataType: "text", type: "POST",
            success: function(response) {
            callback(eval("(" + response + ")"));
        }});
    };


    对于 PUT 和 DELETE 请求(以及不使用将 form 内容作为参数的 POST 请求) 来说, 也可以在 HTTP 头中以 X-XSRFToken 这个参数传递 XSRF token。
    如果需要针对每一个请求处理器定制 XSRF 行为, 你可以重写 RequestHandler.check_xsrf_cookie()。
    例如你需要使用一个不支持 cookie 的 API,  可以通过将 check_xsrf_cookie() 函数设空来禁用 XSRF 保护机制。
    然而如果需要同时支持 cookie 和非 cookie 认证方式, 那么只要当前请求是通过 cookie 进行认证的, 你就应该对其使用 XSRF 保护机制, 这一点至关重要。


  5.静态文件和主动式文件缓存
    通过在应用配置中指定 static_path 选项来提供静态文件服务:
     settings = {
        "static_path": os.path.join(os.path.dirname(__file__), "static"),
        "cookie_secret": "61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=",
        "login_url": "/login",
        "xsrf_cookies": True,
    }
    application = tornado.web.Application([
        (r"/", MainHandler),
        (r"/login", LoginHandler),
        (r"static/(.*)", tornado.web.StaticFileHandler, dict(path=settings['static_path'])),
    ], **settings)


    这样配置后, 所有以 “/static/” 开头的请求, 都会直接访问到指定的静态文件目录,  比如 http://localhost:8888/static/foo.png 会从指定的静态文件目录中访问到 foo.png 这个文件。同时 “/robots.txt” 和 “/favicon.ico” 也是会自动作为静态文件处理(即使它们不是以 “/static/” 开头)。
    (正则表达式 的匹配分组的目的是向 StaticFileHandler 指定所请求的文件名称, 抓取到的分组会以 方法参数的形式传递给处理器。)

    为了提高性能, 在浏览器主动缓存静态文件是个不错的主意。这样浏览器就不需要发送 不必要的 If-Modified-Since 和 Etag 请求, 从而影响页面的渲染速度。
    Tornado 可以通过内建的“静态内容分版(static content versioning)”来直接支持这种功能。

    要使用这个功能, 在模板中就不要直接使用静态文件的 URL 地址了, 你需要在 HTML 中使用 static_url() 这个方法来提供 URL 地址:
     <html>
       <head>
          <title>FriendFeed - {{ _("Home") }}</title>
       </head>
       <body>
         <div><img src="{{ static_url("images/logo.png") }}"/></div>
       </body>
     </html>

    static_url() 函数会将相对地址转成一个类似于 “/static/images/logo.png?v=aae54” 的 URI, v 参数是 logo.png 文件的散列值,  Tornado 服务器会把它发给浏览器, 并以此为依据让浏览器对相关内容做永久缓存。
    由于 v 的值是基于文件的内容计算出来的, 如果你更新了文件, 或者重启了服务器 , 那么就会得到一个新的 v 值, 这样浏览器就会请求服务器以获取新的文件内容。
    如果文件的内容没有改变, 浏览器就会一直使用本地缓存的文件, 这样可以显著提高页面的渲染速度。

    在生产环境下, 可能会使用 nginx(http://nginx.org/) 这样的更有利于静态文件 伺服的服务器, 可以将 Tornado 的文件缓存指定到任何静态文件服务器上面, 下面是 FriendFeed 使用的 nginx 的相关配置:
     location /static/ {
        root /var/friendfeed/static;
        if ($query_string) {
            expires max;
        }
     }


  6.本地化
    不管有没有登陆，当前用户的 locale 设置可以通过两种方式访问到：请求处理器的 self.locale 对象、以及模板中的 locale 值。
    Locale 的名称（如 en_US）可以通过 locale.name 这个变量访问到，可以使用 locale.translate 来进行本地化 翻译。
    在模板中，有一个全局方法叫 _()，它的作用就是进行本地化的翻译。这个 翻译方法有两种使用形式：
       _("Translate this string")

    它会基于当前 locale 设置直接进行翻译，还有一种是：
       _("A person liked this", "%(num)d people liked this", len(people)) % {"num": len(people)}

    这种形式会根据第三个参数来决定是使用单数或是复数的翻译。上面的例子中，如果 len(people) 是 1 的话，就使用第一种形式的翻译，否则，就使用第二种形式 的翻译。
    常用的翻译形式是使用 Python 格式化字符串时的“固定占位符(placeholder)”语法，（例如上面的 %(num)d），和普通占位符比起来，固定占位符的优势是使用时没有顺序限制。

    一个本地化翻译的模板例子：
     <html>
       <head>
          <title>FriendFeed - {{ _("Sign in") }}</title>
       </head>
       <body>
         <form action="{{ request.path }}" method="post">
           <div>{{ _("Username") }} <input type="text" name="username"/></div>
           <div>{{ _("Password") }} <input type="password" name="password"/></div>
           <div><input type="submit" value="{{ _('Sign in') }}"/></div>
           {{ xsrf_form_html() }}
         </form>
       </body>
     </html>

    默认情况下，我们通过 Accept-Language 这个头来判定用户的 locale，如果没有， 则取 en_US 这个值。
    如果希望用户手动设置一个 locale 偏好，可以在处理请求的 类中复写 get_user_locale 方法：
     class BaseHandler(tornado.web.RequestHandler):
        def get_current_user(self):
            user_id = self.get_secure_cookie("user")
            if not user_id: return None
            return self.backend.get_user_by_id(user_id)

        def get_user_locale(self):
            if "locale" not in self.current_user.prefs:
                # Use the Accept-Language header
                return None
            return self.current_user.prefs["locale"]

        def get(self):
            user_locale = self.locale.get("zh_CN")  # 获取指定编码的内容, 英文是: en_US
            print user_locale.translate("Username") # 显示中文的字符串
            print user_locale.translate("Password")
            self.render("index.html")

    如果 get_user_locale 返回 None, 那么就会再去取 Accept-Language header 的值。

    可以使用 tornado.locale.load_translations 方法获取应用中的所有已存在的翻译。
    它会找到包含有特定名字的 CSV 文件的目录，如 es_GT.csv fr_CA.csv 这 些 csv 文件。
    然后从这些 CSV 文件中读取出所有的与特定语言相关的翻译内容。
    典型的用例里面，我们会在 Tornado 服务器的 main() 方法中调用一次该函数：
     def main():
        tornado.locale.load_translations(os.path.join(os.path.dirname(__file__), "translations")) # 本地化的 CSV 文件目录,此目录如果不存在则出错
        start_server() # 启动服务

    translations 目录下的 zh_CN.csv 文件内容(指定编码内容):
        "Username","用户名"
        "Password","密码"
        "Sign in","登录"


    可以使用 tornado.locale.get_supported_locales() 方法得到支持的 locale 列表。
    Tornado 会依据用户当前的 locale 设置以及已有的翻译，为用户选择 一个最佳匹配的显示语言。
    比如，用户的 locale 是 es_GT 而翻译中只支持了 es， 那么 self.locale 就会被设置为 es。
    如果找不到最接近的 locale 匹配，self.locale 就会就会取备用值 es_US。

    查看 locale 模块(https://github.com/facebook/tornado/blob/master/tornado/locale.py) 的代码文档以了解 CSV 文件的格式，以及其它的本地化方法函数。


  7.UI 模块
    Tornado 支持一些 UI 模块，它们可以帮你创建标准的，易被重用的应用程序级的 UI 组件。
    这些 UI 模块就跟特殊的函数调用一样，可以用来渲染页面组件，而这些组件可以有自己的 CSS 和 JavaScript。

    例如你正在写一个博客的应用，你希望在首页和单篇文章的页面都显示文章列表，你可以创建 一个叫做 Entry 的 UI 模块，让他在两个地方分别显示出来。
    首先需要为你的 UI 模块 创建一个 Python 模组文件，就叫 uimodules.py 好了:
     class Entry(tornado.web.UIModule):
        def render(self, entry, show_comments=False):
            return self.render_string("module-entry.html", entry=entry, show_comments=show_comments)

    然后通过 ui_modules 配置项告诉 Tornado 在应用当中使用 uimodules.py：
     import ui_modules # 导入自定义的 UI 文件
     class HomeHandler(tornado.web.RequestHandler):
        def get(self):
            entries = self.db.query("SELECT * FROM entries ORDER BY date DESC")
            self.render("home.html", entries=entries)

    class EntryHandler(tornado.web.RequestHandler):
        def get(self, entry_id):
            entry = self.db.get("SELECT * FROM entries WHERE id = %s", entry_id)
            if not entry: raise tornado.web.HTTPError(404)
            self.render("entry.html", entry=entry)

    application = tornado.web.Application([
        (r"/", HomeHandler),
        (r"/entry/([0-9]+)", EntryHandler),
    ], ui_modules=uimodules)


    在 home.html 中，你不需要写繁复的 HTML 代码，只要引用 Entry 就可以了：
     {% for entry in entries %}
       {% module Entry(entry) %}
     {% end %}

    在 entry.html 里面，你需要使用 show_comments 参数来引用 Entry 模块，用来 显示展开的 Entry 内容：
     {% module Entry(entry, show_comments=True) %}

    你可以为 UI 模型配置自己的 CSS 和 JavaScript ，只要复写 embedded_css、 embedded_javascript、javascipt_files、css_files 就可以了：
     class Entry(tornado.web.UIModule):
        def embedded_css(self):
            return ".entry { margin-bottom: 1em; }"

        def render(self, entry, show_comments=False):
            return self.render_string("module-entry.html", show_comments=show_comments)

    即使一页中有多个相同的 UI 组件，UI 组件的 CSS 和 JavaScript 部分只会被渲染一次。
    CSS 是在页面的 <head> 部分，而 JavaScript 被渲染在页面结尾 </body> 之前的位置。

    在不需要额外 Python 代码的情况下，模板文件也可以当做 UI 模块直接使用。
    例如前面的例子可以以下面的方式实现，只要把这几行放到 module-entry.html中就可以了：
     {{ set_resources(embedded_css=".entry { margin-bottom: 1em; }") }}
    <!-- more template html... -->

    这个修改过的模块式模板可以通过下面的方法调用：
     {% module Template("module-entry.html", show_comments=True) %}

    set_resources 函数只能在 {% module Template(...) %} 调用的模板中访问到。
    和 {% include ... %} 不同，模块式模板使用了和它们的上级模板不同的命名 空间——它们只能访问到全局模板命名空间和它们自己的关键字参数。



    http://sebug.net/paper/books/tornado/#_4
    http://www.tornadoweb.cn/documentation

    Tornado中文版文档:
    https://github.com/breezemind/tornado/tree/master/website/templates/cn



==== 范例1 ==================================================
import tornado
import tornado.httpserver
import tornado.ioloop
import tornado.web
import os.path

# 申明一个 add 函数, 提供给模板文件使用
def add(x, y):
    return (x+y)

# 网页访问处理
class MainHandler(tornado.web.RequestHandler):
    def get(self):
        items = ["item1","item2","item3", '222']
        # 第一个参数是模板文件, 后面不但可以传递参数, 还可以传递函数, 可扩展性很好而且很强大。
        self.render("templates.html", items=items, add=add)

class StoryHandler(tornado.web.RequestHandler):
    def post(self, story_id):
        self.set_header("Content-Type", "text/plain") # 设置头部信息
        self.write("You wrote " + self.get_argument("message")) # get_argument方法接收参数,如果没有传递此参数过来则会出错

        # 不使用模板, 则可直接把内容 write 出去
        self.write("You requested the story " + story_id)
        # 可以多次调用 write,把要显示的内容追加上去
        self.write("<input type='button' value='返回' onclick='window.history.back();'/>")

# 更多的访问处理方式
class IndexHandler(tornado.web.RequestHandler):
    # 参数是 Application 配置中的关键字 参数定义。 比 prepare 更早执行。 一般只是把传入的参数存到成员变量中, 而不会产生一些输出或者调用像 send_error 之类的方法。
    def initialize(self, database):
        self.database = database

    # 无论使用了哪种 HTTP 方法, prepare 都会被调用到。prepare可以产生输出 信息。如果它调用了finish(或send_error` 等函数), 那么整个处理流程 就此结束。
    def prepare(self):
        pass

    # 处理post过来的数据, 接收 service_method, argv 两个URL参数
    def post(self, service_method='', argv=''):
        print('method:POST...')
        print('service_method:' + service_method)

        # 参数处理,按斜杠划分成list
        if argv:
            if argv.startswith('/'): argv = argv[1:]
            if argv.endswith('/'): argv = argv[:-1]
        argv = argv.split('/') if argv else []
        print('argv:' + str(argv))

        print('request.arguments:' + str(self.request.arguments)) # form 表单提交的信息,返回 dict 类型,里面是各参数的值的数组
        print('application:' + str(self.application))

        items = ["item1","item2","item3", 'dfsdfsd']
        self.render("templates.html", items=items, add=add)

    # 处理get提交过来的数据
    def get(self, service_method='', argv=''):
        print('method:GET....')
        self.post(service_method, argv) # 转去调用 post 方法

    # post 和 get 处理之后的调用； data 是处理模板后的内容, string类型, 调用self.write或者什么都不显示时为None
    def finish(self, data=None):
        print('finish   data:\n' + str(data))
        super(IndexHandler, self).finish(data)


# 找不到页面的处理
class NotFoundHandler(tornado.web.RequestHandler):
    def prepare(self):
        NOTFOUND_404 = "404.html" # 404文件地址
        if os.path.exists(NOTFOUND_404):
            #self.set_status(404) # 设 404 状态,浏览器可能会跳转到自己定义的找不到页面,要想全部显示一样就不要设置此状态
            self.render(NOTFOUND_404, url = self.request.full_url())
        else:
            self.send_error(404)


# 网址访问的配置
application = tornado.web.Application([
    (r"/", MainHandler),
    (r"/story/([0-9]+)", StoryHandler),
    (r'^/index/(?P<service_method>.*?)(?P<argv>/.*?)?', IndexHandler, dict(database='test')), # service_method, argv 两个URL参数可传递给 get post 函数处理; database 传给 initialize 函数
    (r"/static/(.*)", tornado.web.StaticFileHandler, {'path':os.path.join(os.path.dirname(__file__), "static")}), # 访问静态文件
    (r"/.*", NotFoundHandler), # 找不到页面,必须放在最后
])

if __name__ == "__main__":
    http_server = tornado.httpserver.HTTPServer(application) # 加载配置
    http_server.listen(8088) # 监听端口号
    tornado.ioloop.IOLoop.instance().start() # 启动
    # 测试网址:
    # http://localhost:8088/
    # http://127.0.0.1:8088/story/555
    # http://127.0.0.1:8088/index/test/test2/kkkk





